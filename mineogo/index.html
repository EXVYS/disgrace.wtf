<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mineogo</title>

    <meta name="description" content="mineogo's personal page. Welcome!">
    <meta property="og:title" content="mineogo">
    <meta property="og:description" content="sdiybtðŸ¥€.">
    <meta property="og:image" content="https://mineogo.is-a.dev/pfp.png">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://mineogo.pages.dev/">
    <meta name="theme-color" content="#7F00FF">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #000000;
            --primary-glow-color: #00ff41;
            --secondary-glow-color: #7F00FF;
            --card-bg-color: rgba(10, 10, 10, 0.7);
            --card-bg-fallback-color: #0A0A0A;
            --border-color: rgba(127, 0, 255, 0.3);
            --text-color: #EAEAEA;
            --subtitle-color: #A0A0A0;
            --verified-color: #1DA1F2;
            --button-bg-color: rgba(127, 0, 255, 0.1);
            --button-hover-bg-color: rgba(127, 0, 255, 0.2);
        }

        *,
        *::before,
        *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
            overscroll-behavior: none;
            touch-action: none;
        }

        body {
            background-color: var(--bg-color);
            font-family: 'Roboto Mono', monospace, 'ui-monospace';
            color: var(--text-color);
            height: 100vh;
            width: 100vw;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            cursor: none;
            overflow: hidden;
            position: fixed;
            overscroll-behavior: none;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body, button, a {
            cursor: none;
        }

        #matrix-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            display: block;
            filter: hue-rotate(0deg);
            animation: hue-cycle 30s linear infinite;
        }

        #neko-rain-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
            overflow: hidden;
        }

        .raining-neko {
            position: absolute;
            top: -150px;
            width: 120px;
            height: 120px;
            object-fit: cover;
            animation: neko-fall linear forwards;
            will-change: transform;
            -webkit-mask-image: radial-gradient(circle, black 60%, transparent 100%);
            mask-image: radial-gradient(circle, black 60%, transparent 100%);
        }

        @keyframes neko-fall {
            to {
                transform: translateY(120vh) rotate(360deg);
            }
        }

        @keyframes hue-cycle {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        #click-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            cursor: pointer;
            opacity: 1;
            transition: opacity 0.7s ease;
        }

        #click-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #click-overlay h2 {
            font-family: 'Roboto Mono', monospace;
            font-size: 2.5rem;
            margin-bottom: 1rem;
            letter-spacing: 2px;
            color: var(--text-color);
        }

        #click-overlay p {
            font-family: 'Roboto Mono', monospace;
            font-size: 1.2rem;
            color: var(--subtitle-color);
            letter-spacing: 1px;
        }

        .main-content {
            position: relative;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .main-content.visible {
            opacity: 1;
        }

        .profile-card {
            background-color: var(--card-bg-fallback-color);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 2rem;
            width: 100%;
            max-width: 550px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5), 0 0 20px var(--border-color);
            transition: all 0.3s ease;
        }
        
        @supports (backdrop-filter: blur(10px)) or (-webkit-backdrop-filter: blur(10px)) {
            .profile-card {
                background-color: var(--card-bg-color);
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
            }
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .pfp {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
            object-fit: cover;
            transition: transform 0.3s ease-in-out;
        }

        .pfp:hover {
            transform: scale(1.1) rotate(5deg);
        }

        .card-header h1 {
            font-size: 2rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0 0.5rem;
        }

        .verified-icon {
            height: 1.6rem;
            width: 1.6rem;
            fill: var(--verified-color);
            flex-shrink: 0;
        }

        .subtitle {
            min-height: 2.5rem;
            font-size: 1rem;
            color: var(--subtitle-color);
            margin-bottom: 1.5rem;
            line-height: 1.5;
        }

        .cursor {
            display: inline-block;
            background-color: var(--text-color);
            width: 3px;
            margin-left: 4px;
            animation: blink 1s infinite;
            position: relative;
            bottom: -2px;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .card-controls {
            border-top: 1px solid var(--border-color);
            padding-top: 1.5rem;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .control-button {
            font-family: 'Roboto Mono', monospace;
            background-color: var(--button-bg-color);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease, opacity 0.2s ease;
        }

        .control-button:hover:not(:disabled),
        .control-button:focus-visible:not(:disabled) {
            background-color: var(--button-hover-bg-color);
            box-shadow: 0 0 10px var(--border-color);
            outline: none;
        }
        
        .control-button:active:not(:disabled) {
            transform: scale(0.98);
        }
        
        .control-button:disabled {
            opacity: 0.6;
            cursor: wait;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        #cursor-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            pointer-events: none;
        }

        .cursor-dot {
            position: absolute;
            background: rgba(128, 128, 128, 0.3);
            border-radius: 50%;
            filter: blur(5px);
            will-change: transform;
            transform-origin: center center;
            transition: opacity 0.3s ease-out;
        }

        .touch-ripple {
            position: fixed;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0);
            animation: ripple-effect 0.6s ease-out;
            pointer-events: none;
            z-index: 9998;
        }

        @keyframes ripple-effect {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }
        
        @media (max-width: 500px) {
            html {
                font-size: 14px;
            }

            .profile-card {
                padding: 1.5rem;
            }

            .card-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 1rem;
            }

            .pfp {
                width: 70px;
                height: 70px;
            }

            .card-header h1 {
                font-size: 1.8rem;
            }
        }
    </style>
</head>
<body>

    <h1 class="sr-only">mineogo's Personal Page</h1>
    
    <div id="click-overlay">
        <h2>mineogo</h2>
        <p>CLICK ANYWHERE TO ENTER</p>
    </div>

    <div id="neko-rain-container" aria-hidden="true"></div>
    <canvas id="matrix-canvas" aria-hidden="true"></canvas>

    <main class="main-content">
        <article class="profile-card" aria-labelledby="profile-heading">
            <header class="card-header">
                <img src="https://mineogo.is-a.dev/pfp.png" alt="A cool looking profile picture." class="pfp">
                <h1 id="profile-heading">
                    mineogo 
                    <svg class="verified-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-label="Verified Badge">
                        <path d="M22.25,12c0,5.66-4.59,10.25-10.25,10.25S1.75,17.66,1.75,12,6.34,1.75,12,1.75,22.25,6.34,22.25,12Zm-11.47,4.47,6-6a.75.75,0,0,0-1.06-1.06l-5.47,5.47L7.78,12.38a.75.75,0,0,0-1.06,1.06l3,3a.75.75,0,0,0,1.06,0Z"></path>
                    </svg>
                </h1>
            </header>

            <p class="subtitle" aria-live="polite" aria-atomic="true">
                <span id="typing-text"></span><span class="cursor" aria-hidden="true">|</span>
            </p>

            <div class="card-controls">
                <button id="oneko-toggle" class="control-button" type="button" aria-pressed="true">cat no follow mouse</button>
                <button id="neko-rain-toggle" class="control-button" type="button" aria-pressed="false" disabled>Loading nekos...</button>
            </div>
        </article>
    </main>

    <audio id="bg-music" preload="auto">
        <source src="https://github.com/MINEOGO/mineogo-songs/raw/refs/heads/main/HeatWaves.mp3" type="audio/mpeg">
    </audio>

    <script id="oneko-script">
      window.onekoManager = (() => {
        const isReducedMotion = window.matchMedia(`(prefers-reduced-motion: reduce)`).matches;
        let nekoEl = null;
        let nekoPosX = 32;
        let nekoPosY = 32;
        let mousePosX = 0;
        let mousePosY = 0;
        let lastFrameTimestamp;
        let idleTime = 0;
        let idleAnimation = null;
        let idleAnimationFrame = 0;
        let animationFrameId = null;

        const nekoSpeed = 10;
        const spriteSets = {
            idle: [[-3, -3]], alert: [[-7, -3]],
            scratchSelf: [[-5, 0],[-6, 0],[-7, 0]],
            scratchWall: [[-5, -1],[-6, -1],[-7, -1]],
            sleep: [[-2, 0],[-2, -1]],
            N: [[-1, -2],[-1, -3]], NE: [[0, -2],[0, -3]], E: [[-3, -2],[-3, -3]],
            SE: [[-2, -2],[-2, -3]], S: [[-4, -2],[-4, -3]], SW: [[-6, -2],[-6, -3]],
            W: [[-5, -2],[-5, -3]], NW: [[-7, -2],[-7, -3]],
        };

        const onMouseMove = (event) => {
            mousePosX = event.clientX;
            mousePosY = event.clientY;
        };

        function setSprite(name, frame) {
            if (!nekoEl) return;
            const sprite = spriteSets[name][frame % spriteSets[name].length];
            nekoEl.style.backgroundPosition = `${sprite[0] * 32}px ${sprite[1] * 32}px`;
        }

        function resetIdleAnimation() {
            idleAnimation = null;
            idleAnimationFrame = 0;
        }

        function idle() {
            idleTime += 1;
            if (idleTime > 10 && Math.random() < 0.3 && !idleAnimation) {
                const availableIdleAnimations = ["scratchSelf"];
                if (nekoPosX < 32 || nekoPosY < 32 || nekoPosX > window.innerWidth - 32 || nekoPosY > window.innerHeight - 32) {
                    availableIdleAnimations.push("scratchWall");
                }
                if (Math.random() < 0.2) availableIdleAnimations.push("sleep");
                idleAnimation = availableIdleAnimations[Math.floor(Math.random() * availableIdleAnimations.length)];
            }
            switch (idleAnimation) {
                case "scratchSelf": case "scratchWall":
                    if (idleAnimationFrame < 8) { setSprite(idleAnimation, idleAnimationFrame); idleAnimationFrame++; return; }
                    break;
                case "sleep":
                    if (idleAnimationFrame < 10) { setSprite("sleep", idleAnimationFrame); idleAnimationFrame++; return; }
                    break;
                default:
                    setSprite("idle", 0); return;
            }
            resetIdleAnimation();
        }

        function frame() {
            const diffX = nekoPosX - mousePosX;
            const diffY = nekoPosY - mousePosY;
            const distance = Math.sqrt(diffX ** 2 + diffY ** 2);
            if (distance < nekoSpeed || distance < 48) { idle(); return; }
            idleTime = 0;
            resetIdleAnimation();
            let direction = 'E';
            const angle = Math.atan2(diffY, diffX);
            const pi = Math.PI;
            if (angle > (pi * 3/4) || angle < (-pi * 3/4)) direction = "W";
            else if (angle < (-pi * 1/4)) direction = "NW";
            else if (angle < (pi * 1/4)) direction = "N";
            else if (angle < (pi * 3/4)) direction = "NE";
            if (Math.abs(diffX) > Math.abs(diffY)) { direction = diffX > 0 ? "W" : "E"; } 
            else { direction = diffY > 0 ? "N" : "S"; }
            if (diffX < 0 && diffY < 0) direction = "SE";
            if (diffX > 0 && diffY < 0) direction = "SW";
            if (diffX < 0 && diffY > 0) direction = "NE";
            if (diffX > 0 && diffY > 0) direction = "NW";
            nekoPosX -= (diffX / distance) * nekoSpeed;
            nekoPosY -= (diffY / distance) * nekoSpeed;
            nekoPosX = Math.min(Math.max(16, nekoPosX), window.innerWidth - 16);
            nekoPosY = Math.min(Math.max(16, nekoPosY), window.innerHeight - 16);
            if(nekoEl){
              nekoEl.style.left = `${nekoPosX - 16}px`;
              nekoEl.style.top = `${nekoPosY - 16}px`;
            }
            setSprite(direction, Math.floor(Date.now() / 100) % 2);
        }

        function onAnimationFrame(timestamp) {
            if (!lastFrameTimestamp) lastFrameTimestamp = timestamp;
            if (timestamp - lastFrameTimestamp > 100) {
                lastFrameTimestamp = timestamp;
                frame();
            }
            animationFrameId = window.requestAnimationFrame(onAnimationFrame);
        }

        return {
            init: () => {
                if (nekoEl || isReducedMotion) return;
                nekoEl = document.createElement("div");
                nekoEl.id = "oneko";
                Object.assign(nekoEl.style, {
                    width: "32px", height: "32px", position: "fixed",
                    backgroundImage: "url('https://sleepie.uk/oneko.gif')",
                    imageRendering: "pixelated", left: "32px", top: "32px",
                    zIndex: "9999", pointerEvents: "none"
                });
                document.body.appendChild(nekoEl);
                document.addEventListener("mousemove", onMouseMove);
                animationFrameId = window.requestAnimationFrame(onAnimationFrame);
            },
            destroy: () => {
                if (!nekoEl) return;
                document.removeEventListener("mousemove", onMouseMove);
                if (animationFrameId) window.cancelAnimationFrame(animationFrameId);
                nekoEl.remove();
                nekoEl = null;
                animationFrameId = null;
            }
        };
      })();
    </script>
    
    <script id="app-script">
        (() => {
            'use strict';
            document.addEventListener('contextmenu', e => e.preventDefault());
            document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
            document.addEventListener('wheel', e => e.preventDefault(), { passive: false });
            
            let isInitialized = false;
            const overlay = document.getElementById('click-overlay');
            const mainContent = document.querySelector('.main-content');
            const audio = document.getElementById('bg-music');
            
            const startExperience = () => {
                if (isInitialized) return;
                isInitialized = true;
                
                overlay.classList.add('hidden');
                setTimeout(() => {
                    overlay.style.display = 'none';
                    mainContent.classList.add('visible');
                    
                    setTimeout(() => {
                        initApp();
                        audio.volume = 0.7;
                        audio.play().catch(() => {});
                    }, 300);
                }, 700);
                
                document.removeEventListener('click', startExperience);
                document.removeEventListener('touchstart', startExperience);
                document.removeEventListener('keydown', startExperience);
            };
            
            const initApp = () => {
                const typingTextElement = document.getElementById('typing-text');
                if (typingTextElement) {
                    const texts = [
                        "he/him", 
                        "@mienoog on disc", 
                        "fuck saika", 
                        "fuck lunar", 
                        "i hate 0zea", 
                        "gyno",
                        "my only bsfs are kai and human."
                    ];
                    let textIndex = 0, charIndex = 0, isDeleting = false;
                    const type = () => {
                        const currentText = texts[textIndex];
                        let speed = isDeleting ? 60 : 120;
                        if (isDeleting) {
                            typingTextElement.textContent = currentText.substring(0, charIndex - 1);
                            charIndex--;
                        } else {
                            typingTextElement.textContent = currentText.substring(0, charIndex + 1);
                            charIndex++;
                        }
                        if (!isDeleting && charIndex === currentText.length) {
                            speed = 2000; isDeleting = true;
                        } else if (isDeleting && charIndex === 0) {
                            isDeleting = false; textIndex = (textIndex + 1) % texts.length; speed = 500;
                        }
                        setTimeout(type, speed);
                    };
                    type();
                }
                
                const canvas = document.getElementById('matrix-canvas');
                if (canvas instanceof HTMLCanvasElement) {
                    const ctx = canvas.getContext('2d');
                    let width, height, columns, drops, animationFrameId;
                    const fontSize = 16, characters = 'ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿ãƒãƒ„ãƒ†ãƒˆãƒŠãƒ‹ãƒŒãƒãƒŽãƒãƒ’ãƒ•ãƒ˜ãƒ›ãƒžãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ¦ãƒ¨ãƒ©ãƒªãƒ«ãƒ¬ãƒ­ãƒ¯ãƒ²ãƒ³ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                    const charArray = characters.split('');
                    const setup = () => {
                        if (animationFrameId) cancelAnimationFrame(animationFrameId);
                        width = window.innerWidth; height = window.innerHeight;
                        canvas.width = width; canvas.height = height;
                        columns = Math.floor(width / fontSize);
                        drops = Array(columns).fill(1);
                    };
                    const draw = () => {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.04)'; ctx.fillRect(0, 0, width, height);
                        ctx.fillStyle = '#00ff41'; ctx.font = `${fontSize}px Roboto Mono`;
                        for (let i = 0; i < drops.length; i++) {
                            const text = charArray[Math.floor(Math.random() * charArray.length)];
                            ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                            if (drops[i] * fontSize > height && Math.random() > 0.975) drops[i] = 0;
                            drops[i]++;
                        }
                    };
                    const animate = () => { draw(); animationFrameId = requestAnimationFrame(animate); };
                    let resizeTimeout;
                    window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(setup, 150); });
                    setup(); animate();
                }

                const nekoRainButton = document.getElementById('neko-rain-toggle');
                const nekoContainer = document.getElementById('neko-rain-container');
                let isNekoRainActive = false;
                let nekoSpawnTimeoutId = null;

                const primeNekoApi = async () => {
                    try {
                        const response = await fetch('https://nekos.best/api/v2/neko');
                        if (!response.ok) throw new Error('API check failed');
                        nekoRainButton.disabled = false;
                        nekoRainButton.textContent = 'Enable Neko Rain';
                    } catch (error) {
                        nekoRainButton.textContent = 'Nekos Unavailable';
                    }
                };

                const spawnNeko = async () => {
                    if (!isNekoRainActive) return;
                    try {
                        const response = await fetch('https://nekos.best/api/v2/neko');
                        if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
                        const data = await response.json();
                        const nekoUrl = data.results?.[0]?.url;
                        if (nekoUrl) {
                            const img = document.createElement('img');
                            img.src = nekoUrl; img.alt = ''; img.className = 'raining-neko';
                            img.onerror = () => img.remove();
                            img.addEventListener('animationend', () => img.remove(), { once: true });
                            img.style.left = `${Math.random() * (window.innerWidth - 120)}px`;
                            img.style.animationDuration = `${Math.random() * 5 + 5}s`;
                            nekoContainer.appendChild(img);
                        }
                    } catch (error) {}
                    if (isNekoRainActive) nekoSpawnTimeoutId = setTimeout(spawnNeko, Math.random() * 400 + 100);
                };

                nekoRainButton.addEventListener('click', () => {
                    isNekoRainActive = !isNekoRainActive;
                    if (isNekoRainActive) {
                        nekoRainButton.textContent = 'Disable Neko Rain';
                        nekoRainButton.setAttribute('aria-pressed', 'true');
                        spawnNeko();
                    } else {
                        nekoRainButton.textContent = 'Enable Neko Rain';
                        nekoRainButton.setAttribute('aria-pressed', 'false');
                        clearTimeout(nekoSpawnTimeoutId);
                        nekoContainer.innerHTML = '';
                    }
                });

                const onekoToggleButton = document.getElementById('oneko-toggle');
                let isOnekoActive = true;
                onekoToggleButton.addEventListener('click', () => {
                    isOnekoActive = !isOnekoActive;
                    if(isOnekoActive) {
                        window.onekoManager.init();
                        onekoToggleButton.textContent = 'cat no follow mouse';
                        onekoToggleButton.setAttribute('aria-pressed', 'true');
                    } else {
                        window.onekoManager.destroy();
                        onekoToggleButton.textContent = 'cat follow mouse';
                        onekoToggleButton.setAttribute('aria-pressed', 'false');
                    }
                });
                
                const setupInteractionEffects = () => {
                    const isPointerFine = window.matchMedia('(pointer: fine)').matches;

                    if (isPointerFine) {
                        const container = document.createElement('div');
                        container.id = 'cursor-container';
                        document.body.appendChild(container);

                        const DOT_COUNT = 20;
                        const dots = [];
                        let mouseX = window.innerWidth / 2;
                        let mouseY = window.innerHeight / 2;

                        for (let i = 0; i < DOT_COUNT; i++) {
                            const dot = document.createElement('div');
                            dot.className = 'cursor-dot';
                            container.appendChild(dot);
                            dots.push({ node: dot, x: mouseX, y: mouseY });
                        }

                        window.addEventListener('mousemove', (e) => {
                            mouseX = e.clientX;
                            mouseY = e.clientY;
                        }, { passive: true });

                        const animateDots = () => {
                            let prevX = mouseX;
                            let prevY = mouseY;
                            dots.forEach((dot, index) => {
                                const currentX = dot.x;
                                const currentY = dot.y;
                                const easing = 0.25;
                                dot.x += (prevX - currentX) * easing;
                                dot.y += (prevY - currentY) * easing;
                                const scale = (DOT_COUNT - index) / DOT_COUNT;
                                const size = 20 * scale;
                                dot.node.style.width = `${size}px`;
                                dot.node.style.height = `${size}px`;
                                dot.node.style.transform = `translate(${dot.x - size / 2}px, ${dot.y - size / 2}px)`;
                                prevX = currentX;
                                prevY = currentY;
                            });
                            requestAnimationFrame(animateDots);
                        };
                        animateDots();
                    } else {
                        document.body.addEventListener('touchstart', (e) => {
                            const touch = e.touches[0];
                            const ripple = document.createElement('div');
                            ripple.className = 'touch-ripple';
                            const size = Math.min(window.innerWidth, window.innerHeight) * 0.075;
                            ripple.style.width = `${size}px`;
                            ripple.style.height = `${size}px`;
                            ripple.style.left = `${touch.clientX - size / 2}px`;
                            ripple.style.top = `${touch.clientY - size / 2}px`;
                            document.body.appendChild(ripple);
                            ripple.addEventListener('animationend', () => ripple.remove(), { once: true });
                        }, { passive: true });
                    }
                };

                primeNekoApi();
                window.onekoManager.init();
                setupInteractionEffects();
            };

            document.addEventListener('click', startExperience);
            document.addEventListener('touchstart', startExperience);
            document.addEventListener('keydown', startExperience);
        })();
    </script>
</body>
</html>
